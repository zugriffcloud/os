// BSD-3-Clause licensed https://github.com/Caligatio/jsSHA
var z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  O = "ARRAYBUFFER not supported by this environment",
  P = "UINT8ARRAY not supported by this environment";
function B(o, n, r, t) {
  let e,
    s,
    i,
    u = n || [0],
    a = (r = r || 0) >>> 3,
    f = t === -1 ? 3 : 0;
  for (e = 0; e < o.length; e += 1)
    (i = e + a),
      (s = i >>> 2),
    u.length <= s && u.push(0),
      (u[s] |= o[e] << (8 * (f + t * (i % 4))));
  return { value: u, binLen: 8 * o.length + r };
}
function I(o, n, r) {
  switch (n) {
    case "UTF8":
    case "UTF16BE":
    case "UTF16LE":
      break;
    default:
      throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
  }
  switch (o) {
    case "HEX":
      return function (t, e, s) {
        return (function (i, u, a, f) {
          let l, h, c, p;
          if (i.length % 2 != 0)
            throw new Error("String of HEX type must be in byte increments");
          let A = u || [0],
            m = (a = a || 0) >>> 3,
            R = f === -1 ? 3 : 0;
          for (l = 0; l < i.length; l += 2) {
            if (((h = parseInt(i.substr(l, 2), 16)), isNaN(h)))
              throw new Error("String of HEX type contains invalid characters");
            for (p = (l >>> 1) + m, c = p >>> 2; A.length <= c; ) A.push(0);
            A[c] |= h << (8 * (R + f * (p % 4)));
          }
          return { value: A, binLen: 4 * i.length + a };
        })(t, e, s, r);
      };
    case "TEXT":
      return function (t, e, s) {
        return (function (i, u, a, f, l) {
          let h,
            c,
            p,
            A,
            m,
            R,
            g,
            d,
            b = 0,
            v = a || [0],
            E = (f = f || 0) >>> 3;
          if (u === "UTF8")
            for (g = l === -1 ? 3 : 0, p = 0; p < i.length; p += 1)
              for (
                h = i.charCodeAt(p),
                  c = [],
                  128 > h
                    ? c.push(h)
                    : 2048 > h
                      ? (c.push(192 | (h >>> 6)), c.push(128 | (63 & h)))
                      : 55296 > h || 57344 <= h
                        ? c.push(
                          224 | (h >>> 12),
                          128 | ((h >>> 6) & 63),
                          128 | (63 & h)
                        )
                        : ((p += 1),
                          (h =
                            65536 +
                            (((1023 & h) << 10) | (1023 & i.charCodeAt(p)))),
                          c.push(
                            240 | (h >>> 18),
                            128 | ((h >>> 12) & 63),
                            128 | ((h >>> 6) & 63),
                            128 | (63 & h)
                          )),
                  A = 0;
                A < c.length;
                A += 1
              ) {
                for (R = b + E, m = R >>> 2; v.length <= m; ) v.push(0);
                (v[m] |= c[A] << (8 * (g + l * (R % 4)))), (b += 1);
              }
          else
            for (
              g = l === -1 ? 2 : 0,
                d =
                  (u === "UTF16LE" && l !== 1) || (u !== "UTF16LE" && l === 1),
                p = 0;
              p < i.length;
              p += 1
            ) {
              for (
                h = i.charCodeAt(p),
                d === !0 && ((A = 255 & h), (h = (A << 8) | (h >>> 8))),
                  R = b + E,
                  m = R >>> 2;
                v.length <= m;

              )
                v.push(0);
              (v[m] |= h << (8 * (g + l * (R % 4)))), (b += 2);
            }
          return { value: v, binLen: 8 * b + f };
        })(t, n, e, s, r);
      };
    case "B64":
      return function (t, e, s) {
        return (function (i, u, a, f) {
          let l,
            h,
            c,
            p,
            A,
            m,
            R,
            g = 0,
            d = u || [0],
            b = (a = a || 0) >>> 3,
            v = f === -1 ? 3 : 0,
            E = i.indexOf("=");
          if (i.search(/^[a-zA-Z0-9=+/]+$/) === -1)
            throw new Error("Invalid character in base-64 string");
          if (((i = i.replace(/=/g, "")), E !== -1 && E < i.length))
            throw new Error("Invalid '=' found in base-64 string");
          for (h = 0; h < i.length; h += 4) {
            for (A = i.substr(h, 4), p = 0, c = 0; c < A.length; c += 1)
              (l = z.indexOf(A.charAt(c))), (p |= l << (18 - 6 * c));
            for (c = 0; c < A.length - 1; c += 1) {
              for (R = g + b, m = R >>> 2; d.length <= m; ) d.push(0);
              (d[m] |= ((p >>> (16 - 8 * c)) & 255) << (8 * (v + f * (R % 4)))),
                (g += 1);
            }
          }
          return { value: d, binLen: 8 * g + a };
        })(t, e, s, r);
      };
    case "BYTES":
      return function (t, e, s) {
        return (function (i, u, a, f) {
          let l,
            h,
            c,
            p,
            A = u || [0],
            m = (a = a || 0) >>> 3,
            R = f === -1 ? 3 : 0;
          for (h = 0; h < i.length; h += 1)
            (l = i.charCodeAt(h)),
              (p = h + m),
              (c = p >>> 2),
            A.length <= c && A.push(0),
              (A[c] |= l << (8 * (R + f * (p % 4))));
          return { value: A, binLen: 8 * i.length + a };
        })(t, e, s, r);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch {
        throw new Error(O);
      }
      return function (t, e, s) {
        return (function (i, u, a, f) {
          return B(new Uint8Array(i), u, a, f);
        })(t, e, s, r);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch {
        throw new Error(P);
      }
      return function (t, e, s) {
        return B(t, e, s, r);
      };
    default:
      throw new Error(
        "format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY"
      );
  }
}
function K(o, n, r, t) {
  switch (o) {
    case "HEX":
      return function (e) {
        return (function (s, i, u, a) {
          let f = "0123456789abcdef",
            l,
            h,
            c = "",
            p = i / 8,
            A = u === -1 ? 3 : 0;
          for (l = 0; l < p; l += 1)
            (h = s[l >>> 2] >>> (8 * (A + u * (l % 4)))),
              (c += f.charAt((h >>> 4) & 15) + f.charAt(15 & h));
          return a.outputUpper ? c.toUpperCase() : c;
        })(e, n, r, t);
      };
    case "B64":
      return function (e) {
        return (function (s, i, u, a) {
          let f,
            l,
            h,
            c,
            p,
            A = "",
            m = i / 8,
            R = u === -1 ? 3 : 0;
          for (f = 0; f < m; f += 3)
            for (
              c = f + 1 < m ? s[(f + 1) >>> 2] : 0,
                p = f + 2 < m ? s[(f + 2) >>> 2] : 0,
                h =
                  (((s[f >>> 2] >>> (8 * (R + u * (f % 4)))) & 255) << 16) |
                  (((c >>> (8 * (R + u * ((f + 1) % 4)))) & 255) << 8) |
                  ((p >>> (8 * (R + u * ((f + 2) % 4)))) & 255),
                l = 0;
              l < 4;
              l += 1
            )
              A +=
                8 * f + 6 * l <= i
                  ? z.charAt((h >>> (6 * (3 - l))) & 63)
                  : a.b64Pad;
          return A;
        })(e, n, r, t);
      };
    case "BYTES":
      return function (e) {
        return (function (s, i, u) {
          let a,
            f,
            l = "",
            h = i / 8,
            c = u === -1 ? 3 : 0;
          for (a = 0; a < h; a += 1)
            (f = (s[a >>> 2] >>> (8 * (c + u * (a % 4)))) & 255),
              (l += String.fromCharCode(f));
          return l;
        })(e, n, r);
      };
    case "ARRAYBUFFER":
      try {
        new ArrayBuffer(0);
      } catch {
        throw new Error(O);
      }
      return function (e) {
        return (function (s, i, u) {
          let a,
            f = i / 8,
            l = new ArrayBuffer(f),
            h = new Uint8Array(l),
            c = u === -1 ? 3 : 0;
          for (a = 0; a < f; a += 1)
            h[a] = (s[a >>> 2] >>> (8 * (c + u * (a % 4)))) & 255;
          return l;
        })(e, n, r);
      };
    case "UINT8ARRAY":
      try {
        new Uint8Array(0);
      } catch {
        throw new Error(P);
      }
      return function (e) {
        return (function (s, i, u) {
          let a,
            f = i / 8,
            l = u === -1 ? 3 : 0,
            h = new Uint8Array(f);
          for (a = 0; a < f; a += 1)
            h[a] = (s[a >>> 2] >>> (8 * (l + u * (a % 4)))) & 255;
          return h;
        })(e, n, r);
      };
    default:
      throw new Error(
        "format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY"
      );
  }
}
var x = 4294967296,
  _ = "Cannot set numRounds with MAC";
function S(o, n) {
  let r,
    t,
    e = o.binLen >>> 3,
    s = n.binLen >>> 3,
    i = e << 3,
    u = (4 - e) << 3;
  if (e % 4 != 0) {
    for (r = 0; r < s; r += 4)
      (t = (e + r) >>> 2),
        (o.value[t] |= n.value[r >>> 2] << i),
        o.value.push(0),
        (o.value[t + 1] |= n.value[r >>> 2] >>> u);
    return (
      (o.value.length << 2) - 4 >= s + e && o.value.pop(),
        { value: o.value, binLen: o.binLen + n.binLen }
    );
  }
  return { value: o.value.concat(n.value), binLen: o.binLen + n.binLen };
}
function Y(o) {
  let n = { outputUpper: !1, b64Pad: "=", outputLen: -1 },
    r = o || {},
    t = "Output length must be a multiple of 8";
  if (
    ((n.outputUpper = r.outputUpper || !1),
    r.b64Pad && (n.b64Pad = r.b64Pad),
      r.outputLen)
  ) {
    if (r.outputLen % 8 != 0) throw new Error(t);
    n.outputLen = r.outputLen;
  } else if (r.shakeLen) {
    if (r.shakeLen % 8 != 0) throw new Error(t);
    n.outputLen = r.shakeLen;
  }
  if (typeof n.outputUpper != "boolean")
    throw new Error("Invalid outputUpper formatting option");
  if (typeof n.b64Pad != "string")
    throw new Error("Invalid b64Pad formatting option");
  return n;
}
function T(o, n, r, t) {
  let e = o + " must include a value and format";
  if (!n) {
    if (!t) throw new Error(e);
    return t;
  }
  if (n.value === void 0 || !n.format) throw new Error(e);
  return I(n.format, n.encoding || "UTF8", r)(n.value);
}
var F = class {
    constructor(n, r, t) {
      let e = t || {};
      if (
        ((this.t = r),
          (this.i = e.encoding || "UTF8"),
          (this.numRounds = e.numRounds || 1),
        isNaN(this.numRounds) ||
        this.numRounds !== parseInt(this.numRounds, 10) ||
        1 > this.numRounds)
      )
        throw new Error("numRounds must a integer >= 1");
      (this.o = n),
        (this.h = []),
        (this.u = 0),
        (this.l = !1),
        (this.A = 0),
        (this.p = !1),
        (this.m = []),
        (this.U = []);
    }
    update(n) {
      let r,
        t = 0,
        e = this.R >>> 5,
        s = this.C(n, this.h, this.u),
        i = s.binLen,
        u = s.value,
        a = i >>> 5;
      for (r = 0; r < a; r += e)
        t + this.R <= i &&
        ((this.v = this.H(u.slice(r, r + e), this.v)), (t += this.R));
      return (
        (this.A += t),
          (this.h = u.slice(t >>> 5)),
          (this.u = i % this.R),
          (this.l = !0),
          this
      );
    }
    getHash(n, r) {
      let t,
        e,
        s = this.T,
        i = Y(r);
      if (this.F) {
        if (i.outputLen === -1)
          throw new Error("Output length must be specified in options");
        s = i.outputLen;
      }
      let u = K(n, s, this.g, i);
      if (this.p && this.S) return u(this.S(i));
      for (
        e = this.L(this.h.slice(), this.u, this.A, this.B(this.v), s), t = 1;
        t < this.numRounds;
        t += 1
      )
        this.F &&
        s % 32 != 0 &&
        (e[e.length - 1] &= 16777215 >>> (24 - (s % 32))),
          (e = this.L(e, s, 0, this.K(this.o), s));
      return u(e);
    }
    setHMACKey(n, r, t) {
      if (!this.k) throw new Error("Variant does not support HMAC");
      if (this.l) throw new Error("Cannot set MAC key after calling update");
      let e = I(r, (t || {}).encoding || "UTF8", this.g);
      this.M(e(n));
    }
    M(n) {
      let r = this.R >>> 3,
        t = r / 4 - 1,
        e;
      if (this.numRounds !== 1) throw new Error(_);
      if (this.p) throw new Error("MAC key already set");
      for (
        r < n.binLen / 8 &&
        (n.value = this.L(n.value, n.binLen, 0, this.K(this.o), this.T));
        n.value.length <= t;

      )
        n.value.push(0);
      for (e = 0; e <= t; e += 1)
        (this.m[e] = 909522486 ^ n.value[e]),
          (this.U[e] = 1549556828 ^ n.value[e]);
      (this.v = this.H(this.m, this.v)), (this.A = this.R), (this.p = !0);
    }
    getHMAC(n, r) {
      let t = Y(r);
      return K(n, this.T, this.g, t)(this.Y());
    }
    Y() {
      let n;
      if (!this.p)
        throw new Error("Cannot call getHMAC without first setting MAC key");
      let r = this.L(this.h.slice(), this.u, this.A, this.B(this.v), this.T);
      return (
        (n = this.H(this.U, this.K(this.o))),
          (n = this.L(r, this.T, this.R, n, this.T)),
          n
      );
    }
  },
  w = class {
    constructor(n, r) {
      (this.N = n), (this.I = r);
    }
  };
function M(o, n) {
  let r;
  return n > 32
    ? ((r = 64 - n), new w((o.I << n) | (o.N >>> r), (o.N << n) | (o.I >>> r)))
    : n !== 0
      ? ((r = 32 - n), new w((o.N << n) | (o.I >>> r), (o.I << n) | (o.N >>> r)))
      : o;
}
function U(o, n) {
  return new w(o.N ^ n.N, o.I ^ n.I);
}
var j = [
    new w(0, 1),
    new w(0, 32898),
    new w(2147483648, 32906),
    new w(2147483648, 2147516416),
    new w(0, 32907),
    new w(0, 2147483649),
    new w(2147483648, 2147516545),
    new w(2147483648, 32777),
    new w(0, 138),
    new w(0, 136),
    new w(0, 2147516425),
    new w(0, 2147483658),
    new w(0, 2147516555),
    new w(2147483648, 139),
    new w(2147483648, 32905),
    new w(2147483648, 32771),
    new w(2147483648, 32770),
    new w(2147483648, 128),
    new w(0, 32778),
    new w(2147483648, 2147483658),
    new w(2147483648, 2147516545),
    new w(2147483648, 32896),
    new w(0, 2147483649),
    new w(2147483648, 2147516424),
  ],
  q = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14],
  ];
function C(o) {
  let n,
    r = [];
  for (n = 0; n < 5; n += 1)
    r[n] = [new w(0, 0), new w(0, 0), new w(0, 0), new w(0, 0), new w(0, 0)];
  return r;
}
function D(o) {
  let n,
    r = [];
  for (n = 0; n < 5; n += 1) r[n] = o[n].slice();
  return r;
}
function k(o, n) {
  let r,
    t,
    e,
    s,
    i = [],
    u = [];
  if (o !== null)
    for (t = 0; t < o.length; t += 2)
      n[(t >>> 1) % 5][((t >>> 1) / 5) | 0] = U(
        n[(t >>> 1) % 5][((t >>> 1) / 5) | 0],
        new w(o[t + 1], o[t])
      );
  for (r = 0; r < 24; r += 1) {
    for (s = C(), t = 0; t < 5; t += 1)
      i[t] =
        ((a = n[t][0]),
          (f = n[t][1]),
          (l = n[t][2]),
          (h = n[t][3]),
          (c = n[t][4]),
          new w(a.N ^ f.N ^ l.N ^ h.N ^ c.N, a.I ^ f.I ^ l.I ^ h.I ^ c.I));
    for (t = 0; t < 5; t += 1) u[t] = U(i[(t + 4) % 5], M(i[(t + 1) % 5], 1));
    for (t = 0; t < 5; t += 1)
      for (e = 0; e < 5; e += 1) n[t][e] = U(n[t][e], u[t]);
    for (t = 0; t < 5; t += 1)
      for (e = 0; e < 5; e += 1)
        s[e][(2 * t + 3 * e) % 5] = M(n[t][e], q[t][e]);
    for (t = 0; t < 5; t += 1)
      for (e = 0; e < 5; e += 1)
        n[t][e] = U(
          s[t][e],
          new w(
            ~s[(t + 1) % 5][e].N & s[(t + 2) % 5][e].N,
            ~s[(t + 1) % 5][e].I & s[(t + 2) % 5][e].I
          )
        );
    n[0][0] = U(n[0][0], j[r]);
  }
  var a, f, l, h, c;
  return n;
}
function V(o) {
  let n,
    r,
    t = 0,
    e = [0, 0],
    s = [4294967295 & o, (o / x) & 2097151];
  for (n = 6; n >= 0; n--)
    (r = (s[n >> 2] >>> (8 * n)) & 255),
    (r === 0 && t === 0) ||
    ((e[(t + 1) >> 2] |= r << (8 * (t + 1))), (t += 1));
  return (
    (t = t !== 0 ? t : 1),
      (e[0] |= t),
      { value: t + 1 > 4 ? e : [e[0]], binLen: 8 + 8 * t }
  );
}
function N(o) {
  return S(V(o.binLen), o);
}
function X(o, n) {
  let r,
    t = V(n);
  t = S(t, o);
  let e = n >>> 2,
    s = (e - (t.value.length % e)) % e;
  for (r = 0; r < s; r++) t.value.push(0);
  return t.value;
}
var H = class extends F {
  constructor(n, r, t) {
    let e = 6,
      s = 0;
    super(n, r, t);
    let i = t || {};
    if (this.numRounds !== 1) {
      if (i.kmacKey || i.hmacKey) throw new Error(_);
      if (this.o === "CSHAKE128" || this.o === "CSHAKE256")
        throw new Error("Cannot set numRounds for CSHAKE variants");
    }
    switch (
      ((this.g = 1),
        (this.C = I(this.t, this.i, this.g)),
        (this.H = k),
        (this.B = D),
        (this.K = C),
        (this.v = C()),
        (this.F = !1),
        n)
      ) {
      case "SHA3-224":
        (this.R = s = 1152), (this.T = 224), (this.k = !0), (this.S = this.Y);
        break;
      case "SHA3-256":
        (this.R = s = 1088), (this.T = 256), (this.k = !0), (this.S = this.Y);
        break;
      case "SHA3-384":
        (this.R = s = 832), (this.T = 384), (this.k = !0), (this.S = this.Y);
        break;
      case "SHA3-512":
        (this.R = s = 576), (this.T = 512), (this.k = !0), (this.S = this.Y);
        break;
      case "SHAKE128":
        (e = 31),
          (this.R = s = 1344),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = null);
        break;
      case "SHAKE256":
        (e = 31),
          (this.R = s = 1088),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = null);
        break;
      case "KMAC128":
        (e = 4),
          (this.R = s = 1344),
          this.X(t),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = this._);
        break;
      case "KMAC256":
        (e = 4),
          (this.R = s = 1088),
          this.X(t),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = this._);
        break;
      case "CSHAKE128":
        (this.R = s = 1344),
          (e = this.O(t)),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = null);
        break;
      case "CSHAKE256":
        (this.R = s = 1088),
          (e = this.O(t)),
          (this.T = -1),
          (this.F = !0),
          (this.k = !1),
          (this.S = null);
        break;
      default:
        throw new Error("Chosen SHA variant is not supported");
    }
    (this.L = function (u, a, f, l, h) {
      return (function (c, p, A, m, R, g, d) {
        let b,
          v,
          E = 0,
          L = [],
          y = R >>> 5,
          Z = p >>> 5;
        for (b = 0; b < Z && p >= R; b += y)
          (m = k(c.slice(b, b + y), m)), (p -= R);
        for (c = c.slice(b), p %= R; c.length < y; ) c.push(0);
        for (
          b = p >>> 3,
            c[b >> 2] ^= g << ((b % 4) * 8),
            c[y - 1] ^= 2147483648,
            m = k(c, m);
          32 * L.length < d &&
          ((v = m[E % 5][(E / 5) | 0]), L.push(v.I), !(32 * L.length >= d));

        )
          L.push(v.N), (E += 1), (64 * E) % R == 0 && (k(null, m), (E = 0));
        return L;
      })(u, a, 0, l, s, e, h);
    }),
    i.hmacKey && this.M(T("hmacKey", i.hmacKey, this.g));
  }
  O(n, r) {
    let t = (function (s) {
      let i = s || {};
      return {
        funcName: T("funcName", i.funcName, 1, { value: [], binLen: 0 }),
        customization: T("Customization", i.customization, 1, {
          value: [],
          binLen: 0,
        }),
      };
    })(n || {});
    r && (t.funcName = r);
    let e = S(N(t.funcName), N(t.customization));
    if (t.customization.binLen !== 0 || t.funcName.binLen !== 0) {
      let s = X(e, this.R >>> 3);
      for (let i = 0; i < s.length; i += this.R >>> 5)
        (this.v = this.H(s.slice(i, i + (this.R >>> 5)), this.v)),
          (this.A += this.R);
      return 4;
    }
    return 31;
  }
  X(n) {
    let r = (function (e) {
      let s = e || {};
      return {
        kmacKey: T("kmacKey", s.kmacKey, 1),
        funcName: { value: [1128353099], binLen: 32 },
        customization: T("Customization", s.customization, 1, {
          value: [],
          binLen: 0,
        }),
      };
    })(n || {});
    this.O(n, r.funcName);
    let t = X(N(r.kmacKey), this.R >>> 3);
    for (let e = 0; e < t.length; e += this.R >>> 5)
      (this.v = this.H(t.slice(e, e + (this.R >>> 5)), this.v)),
        (this.A += this.R);
    this.p = !0;
  }
  _(n) {
    let r = S(
      { value: this.h.slice(), binLen: this.u },
      (function (t) {
        let e,
          s,
          i = 0,
          u = [0, 0],
          a = [4294967295 & t, (t / x) & 2097151];
        for (e = 6; e >= 0; e--)
          (s = (a[e >> 2] >>> (8 * e)) & 255),
          (s === 0 && i === 0) || ((u[i >> 2] |= s << (8 * i)), (i += 1));
        return (
          (i = i !== 0 ? i : 1),
            (u[i >> 2] |= i << (8 * i)),
            { value: i + 1 > 4 ? u : [u[0]], binLen: 8 + 8 * i }
        );
      })(n.outputLen)
    );
    return this.L(r.value, r.binLen, this.A, this.B(this.v), n.outputLen);
  }
};
function Q(o) {
  return new H("SHA3-384", "TEXT").update(o).getHash("B64");
}
export { Q as sha3_384_b64 };
